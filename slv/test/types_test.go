// Code generated by moq; DO NOT EDIT
// github.com/matryer/moq

package test

import (
	"sync"
)

var (
	locktestLoaderMockListFileNames sync.RWMutex
	locktestLoaderMockLoad          sync.RWMutex
)

// testLoaderMock is a mock implementation of testLoader.
//
//     func TestSomethingThatUsestestLoader(t *testing.T) {
//
//         // make and configure a mocked testLoader
//         mockedtestLoader := &testLoaderMock{
//             ListFileNamesFunc: func() ([]string, error) {
// 	               panic("TODO: mock out the ListFileNames method")
//             },
//             LoadFunc: func(filename string) ([]testCase, error) {
// 	               panic("TODO: mock out the Load method")
//             },
//         }
//
//         // TODO: use mockedtestLoader in code that requires testLoader
//         //       and then make assertions.
//
//     }
type testLoaderMock struct {
	// ListFileNamesFunc mocks the ListFileNames method.
	ListFileNamesFunc func() ([]string, error)

	// LoadFunc mocks the Load method.
	LoadFunc func(filename string) ([]testCase, error)

	// calls tracks calls to the methods.
	calls struct {
		// ListFileNames holds details about calls to the ListFileNames method.
		ListFileNames []struct {
		}
		// Load holds details about calls to the Load method.
		Load []struct {
			// Filename is the filename argument value.
			Filename string
		}
	}
}

// ListFileNames calls ListFileNamesFunc.
func (mock *testLoaderMock) ListFileNames() ([]string, error) {
	if mock.ListFileNamesFunc == nil {
		panic("moq: testLoaderMock.ListFileNamesFunc is nil but testLoader.ListFileNames was just called")
	}
	callInfo := struct {
	}{}
	locktestLoaderMockListFileNames.Lock()
	mock.calls.ListFileNames = append(mock.calls.ListFileNames, callInfo)
	locktestLoaderMockListFileNames.Unlock()
	return mock.ListFileNamesFunc()
}

// ListFileNamesCalls gets all the calls that were made to ListFileNames.
// Check the length with:
//     len(mockedtestLoader.ListFileNamesCalls())
func (mock *testLoaderMock) ListFileNamesCalls() []struct {
} {
	var calls []struct {
	}
	locktestLoaderMockListFileNames.RLock()
	calls = mock.calls.ListFileNames
	locktestLoaderMockListFileNames.RUnlock()
	return calls
}

// Load calls LoadFunc.
func (mock *testLoaderMock) Load(filename string) ([]testCase, error) {
	if mock.LoadFunc == nil {
		panic("moq: testLoaderMock.LoadFunc is nil but testLoader.Load was just called")
	}
	callInfo := struct {
		Filename string
	}{
		Filename: filename,
	}
	locktestLoaderMockLoad.Lock()
	mock.calls.Load = append(mock.calls.Load, callInfo)
	locktestLoaderMockLoad.Unlock()
	return mock.LoadFunc(filename)
}

// LoadCalls gets all the calls that were made to Load.
// Check the length with:
//     len(mockedtestLoader.LoadCalls())
func (mock *testLoaderMock) LoadCalls() []struct {
	Filename string
} {
	var calls []struct {
		Filename string
	}
	locktestLoaderMockLoad.RLock()
	calls = mock.calls.Load
	locktestLoaderMockLoad.RUnlock()
	return calls
}

var (
	locktestResultHandlerMockOnCaseEnd sync.RWMutex
	locktestResultHandlerMockOnEnd     sync.RWMutex
)

// testResultHandlerMock is a mock implementation of testResultHandler.
//
//     func TestSomethingThatUsestestResultHandler(t *testing.T) {
//
//         // make and configure a mocked testResultHandler
//         mockedtestResultHandler := &testResultHandlerMock{
//             OnCaseEndFunc: func(result *testResult)  {
// 	               panic("TODO: mock out the OnCaseEnd method")
//             },
//             OnEndFunc: func(total *totalTestResult)  {
// 	               panic("TODO: mock out the OnEnd method")
//             },
//         }
//
//         // TODO: use mockedtestResultHandler in code that requires testResultHandler
//         //       and then make assertions.
//
//     }
type testResultHandlerMock struct {
	// OnCaseEndFunc mocks the OnCaseEnd method.
	OnCaseEndFunc func(result *testResult)

	// OnEndFunc mocks the OnEnd method.
	OnEndFunc func(total *totalTestResult)

	// calls tracks calls to the methods.
	calls struct {
		// OnCaseEnd holds details about calls to the OnCaseEnd method.
		OnCaseEnd []struct {
			// Result is the result argument value.
			Result *testResult
		}
		// OnEnd holds details about calls to the OnEnd method.
		OnEnd []struct {
			// Total is the total argument value.
			Total *totalTestResult
		}
	}
}

// OnCaseEnd calls OnCaseEndFunc.
func (mock *testResultHandlerMock) OnCaseEnd(result *testResult) {
	if mock.OnCaseEndFunc == nil {
		panic("moq: testResultHandlerMock.OnCaseEndFunc is nil but testResultHandler.OnCaseEnd was just called")
	}
	callInfo := struct {
		Result *testResult
	}{
		Result: result,
	}
	locktestResultHandlerMockOnCaseEnd.Lock()
	mock.calls.OnCaseEnd = append(mock.calls.OnCaseEnd, callInfo)
	locktestResultHandlerMockOnCaseEnd.Unlock()
	mock.OnCaseEndFunc(result)
}

// OnCaseEndCalls gets all the calls that were made to OnCaseEnd.
// Check the length with:
//     len(mockedtestResultHandler.OnCaseEndCalls())
func (mock *testResultHandlerMock) OnCaseEndCalls() []struct {
	Result *testResult
} {
	var calls []struct {
		Result *testResult
	}
	locktestResultHandlerMockOnCaseEnd.RLock()
	calls = mock.calls.OnCaseEnd
	locktestResultHandlerMockOnCaseEnd.RUnlock()
	return calls
}

// OnEnd calls OnEndFunc.
func (mock *testResultHandlerMock) OnEnd(total *totalTestResult) {
	if mock.OnEndFunc == nil {
		panic("moq: testResultHandlerMock.OnEndFunc is nil but testResultHandler.OnEnd was just called")
	}
	callInfo := struct {
		Total *totalTestResult
	}{
		Total: total,
	}
	locktestResultHandlerMockOnEnd.Lock()
	mock.calls.OnEnd = append(mock.calls.OnEnd, callInfo)
	locktestResultHandlerMockOnEnd.Unlock()
	mock.OnEndFunc(total)
}

// OnEndCalls gets all the calls that were made to OnEnd.
// Check the length with:
//     len(mockedtestResultHandler.OnEndCalls())
func (mock *testResultHandlerMock) OnEndCalls() []struct {
	Total *totalTestResult
} {
	var calls []struct {
		Total *totalTestResult
	}
	locktestResultHandlerMockOnEnd.RLock()
	calls = mock.calls.OnEnd
	locktestResultHandlerMockOnEnd.RUnlock()
	return calls
}
